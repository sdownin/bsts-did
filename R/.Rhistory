hi.perf.lo.gro=list(b4= .7,b5=.01,effect.types=effect.types, sims=NA)
)
i = 1
key <- names(simlist)[i]
sim <- simlist[[key]]
cat(sprintf('\nScenario label: %s\n\n', key))
cat(str(simlist[[key]]))
simlist[[key]]$sims <- runInternalInterventionSim(
n = n, ## NUMBER OF FIRMS
npds = npds, ## NUMBER OF PERIODS
intpd = round( npds / 5 ), ## intervention after first section
ystart = 0,
effect.types = effect.types,
benchmark.type = 'self', ## 'all', 'self'
treat.threshold = 0.03,
##
b4 = sim$b4, ## past performance
b5 = sim$b5, ## growth (linear function of time t)
##
w0 = 1.3,  ## constant
w1 = 0.3,  ## linear
w2 = 0.12 ## quadratic
)
##=================================
##
## Internal Intervention Simulation Function
##
##=================================
runInternalInterventionSim <- function(
n = 50, ## NUMBER OF FIRMS
npds = 60, ## NUMBER OF PERIODS
intpd = round( npds / 5 ), ## intervention after first fifth
ystart = 0,
effect.types = c('constant','quadratic','geometric'), ## treatment effect shapes
benchmark.type = 'self', ## 'all', 'self'
treat.threshold = 0.02, ## treatment threshold (either probability or quantile of performance below which low performer(s) self-select into treatment)
seed = 54321,
##
b0 = .001, ## intercept
b1 = .001, ## treatment dummy
b2 = .001, ## post intervention dummy
b3 = .001, ## treatment effect (replaced by function b3Func() for dynamic treatment effect)
b4 = 1/3, ## spillover of past performance on current performance (how much of treatment effect persists across periods)
b5 = .01, ## growth rate (linear effect of time: proportion of time t added to linear combination in yFunc() performance )
##
w0 = 1.3,
w1 = 0.3,
w2 = 0.12,
#
g0 = .1,
g1 = .1,
##
logit.shift = 1,
logit.scale = 1,
#
plot.save = TRUE,
plot.show = TRUE,
plot.wide.w=10,
plot.wide.h=5,
plot.tall.w=5,
plot.tall.h=10,
plot.sq.w=9,
plot.sq.h=9,
plot.dpi=300,
##
ci.l=.025,
ci.u=.975,
...
) {
## --- BEGIN SIM ---
TIME <- as.numeric(Sys.time())
ntypes <- length(effect.types)
sim.count <- ntypes * npds * n
cat(sprintf('\nRunning Internal Intervention Simulation for %s iterations:\n  %s firms, %s periods, %s effect types\n',
sim.count, n, npds, ntypes))
## Initialize progress bar
counter <- 0
pb <- txtProgressBar(min = 0,      # Minimum value of the progress bar
max = sim.count, # Maximum value of the progress bar
style = 3,    # Progress bar style (also available style = 1 and style = 2)
width = 80,   # Progress bar width. Defaults to getOption("width")
char = "=")   # Character used to create the bar
set.seed(seed)
##================================
## MAIN RUN
##--------------------------------
## VARIABLES IN SIMULATION PER FIRM PER PERIOD
# y <- NA
# x1 <- NA
# x2 <- NA
# b3 <- NA
# u <- NA
# v <- NA
##------
## OUTPUT OBJECTS (to be output as list)
df <- data.frame(stringsAsFactors = F)
df.t0 <- NA
# df.summary=NA
# df.t0.summary=NA
# df.plot.treat.map=NA
# plot.allseries=NA
# plot.group=NA
# plot.group.staggered=NA
for (k in 1:length(effect.types))
{
effect.type <- effect.types[k]
for (t in 1:npds) ## PERIOD LOOP
{
# cat(sprintf('\n\n\n----- t = %s -----\n\n\n',t))
for (i in 1:n) ## FIRMS LOOP
{
# cat(sprintf(' i = %s \n',i))
## noise terms
v <- rnorm(n=1,mean=0,sd=.5)  ##- .5 ##
u <- rnorm(n=1,mean=0,sd=.5) ##
## focal firm past performance
y.t.minus1 <- if (t==1) { ystart } else { df$y[which(df$firm==i & df$t==t-1)][1] }
## post-intervention dummy var
x2 <- x2Func(t, intpd)
## periods after intervention
t.post.intpd <- if(t <= intpd) {
0
} else {
ifelse(max(df$x3[which(df$firm==i)]) > 0, ## has had post-intervention-pd treatment
df$firm.t.post.intpd[which(df$firm==i & df$t==t-1)] + 1,
0)
}
##------------------------------------------------------
## Get past performance records for treat.rule == 'past'
##------------------------------------------------------
# perf.records <- if (i==1) { ## if first firm (df not updated yet)
#   if (t==1){ ystart } else { y } ## first firm must use default start value of performance or past performance in 'y' vector
# } else {
#   if (t==1) {
#     switch(benchmark.type,
#            "self"=ystart,  ## focal firm i not in data.frame yet when t==1, so just use ystart
#            "all"=df$y)
#   } else {
#     switch(benchmark.type,
#            "self" = df$y[which(df$firm == i)],
#            "all" = df$y)
#   }
# }
len.memory <- 3
.ts <- sapply(1:len.memory, function(a)max(t-a,0))
t.in.memory <- .ts[.ts > 0]
perf.records <- if (t==1) { ## if first firm record
switch(benchmark.type,
"self" = ystart, ## first time for firm i must use default start value of performance or past performance in 'y' vector
"all" = df$y)
} else {
switch(benchmark.type,
"self" = df$y[which(df$firm == i & df$t %in% t.in.memory)],
"all" = df$y[which(df$t %in% t.in.memory)])
}
# print('perf.recrods')
# print(perf.records)
## Treatment dummy (firm self-select into treatment based on treat.rule)
x3.t.minus1 <- if (t==1) { 0 } else { df$x3[which(df$firm==i & df$t==t-1)][1] }
x1 <- x1Func(x3.t.minus1,
g0, g1, y.t.minus1, v,
treat.rule = 'worst',
treat.threshold = treat.threshold, #0.5 for 'worst'; 0.1 for 'past' (?)
records=perf.records,
logit.shift, logit.scale)
# .x1.t <- x1Func(g0, g1, v[t],  y.t.minus1,
#                 logit.shift, logit.scale)
# x1[t] <- .x1.t # round(.x1.t)
# x1[t] <- sample(0:1, size = 1, prob = c(.x1.t, 1-.x1.t))
# .x1.mean <- ifelse(t==1, 0, mean(x1vec) )
# x1vec[t] <- ifelse(.x1.t > .x1.mean, 1, 0)
b3 <- b3Func(t.post.intpd, x2, type=effect.type,
w0=ifelse(effect.type=='geometric', 7, 1.3))
y <- yFunc(b0, b1, b2, b3, b4, b5, x1, x2, y.t.minus1, t, u)
df.t <- data.frame(firm=as.numeric(i), t=t, firm.t.post.intpd=t.post.intpd,
effect.type=effect.type,
y=y, x1=x1, x2=x2, x3=x1 * x2,
b1=b1, b2=b2, b3=b3,
u=u, v=v,
group=NA, group.color=NA,
stringsAsFactors = F)
df <- rbind(df, df.t)
## Update Progress Bar
## starting at 0 --> add 1 after completing first item / before progress bar update
counter <- counter + 1
setTxtProgressBar(pb, counter)
}
##=================================
##
## Internal Intervention Simulation Function
##
##=================================
runInternalInterventionSim <- function(
n = 50, ## NUMBER OF FIRMS
npds = 60, ## NUMBER OF PERIODS
intpd = round( npds / 5 ), ## intervention after first fifth
ystart = 0,
effect.types = c('constant','quadratic','geometric'), ## treatment effect shapes
benchmark.type = 'self', ## 'all', 'self'
treat.threshold = 0.02, ## treatment threshold (either probability or quantile of performance below which low performer(s) self-select into treatment)
seed = 54321,
##
b0 = .001, ## intercept
b1 = .001, ## treatment dummy
b2 = .001, ## post intervention dummy
b3 = .001, ## treatment effect (replaced by function b3Func() for dynamic treatment effect)
b4 = 1/3, ## spillover of past performance on current performance (how much of treatment effect persists across periods)
b5 = .01, ## growth rate (linear effect of time: proportion of time t added to linear combination in yFunc() performance )
##
w0 = 1.3,
w1 = 0.3,
w2 = 0.12,
#
g0 = .1,
g1 = .1,
##
logit.shift = 1,
logit.scale = 1,
#
plot.save = TRUE,
plot.show = TRUE,
plot.wide.w=10,
plot.wide.h=5,
plot.tall.w=5,
plot.tall.h=10,
plot.sq.w=9,
plot.sq.h=9,
plot.dpi=300,
##
ci.l=.025,
ci.u=.975,
...
) {
## --- BEGIN SIM ---
TIME <- as.numeric(Sys.time())
ntypes <- length(effect.types)
sim.count <- ntypes * npds * n
cat(sprintf('\nRunning Internal Intervention Simulation for %s iterations:\n  %s firms, %s periods, %s effect types\n',
sim.count, n, npds, ntypes))
## Initialize progress bar
counter <- 0
pb <- txtProgressBar(min = 0,      # Minimum value of the progress bar
max = sim.count, # Maximum value of the progress bar
style = 3,    # Progress bar style (also available style = 1 and style = 2)
width = 80,   # Progress bar width. Defaults to getOption("width")
char = "=")   # Character used to create the bar
set.seed(seed)
##================================
## MAIN RUN
##--------------------------------
## VARIABLES IN SIMULATION PER FIRM PER PERIOD
# y <- NA
# x1 <- NA
# x2 <- NA
# b3 <- NA
# u <- NA
# v <- NA
##------
## OUTPUT OBJECTS (to be output as list)
df <- data.frame(stringsAsFactors = F)
df.t0 <- NA
# df.summary=NA
# df.t0.summary=NA
# df.plot.treat.map=NA
# plot.allseries=NA
# plot.group=NA
# plot.group.staggered=NA
for (k in 1:length(effect.types))
{
effect.type <- effect.types[k]
for (t in 1:npds) ## PERIOD LOOP
{
# cat(sprintf('\n\n\n----- t = %s -----\n\n\n',t))
for (i in 1:n) ## FIRMS LOOP
{
# cat(sprintf(' i = %s \n',i))
## noise terms
v <- rnorm(n=1,mean=0,sd=.5)  ##- .5 ##
u <- rnorm(n=1,mean=0,sd=.5) ##
## focal firm past performance
y.t.minus1 <- if (t==1) { ystart } else { df$y[which(df$firm==i & df$t==t-1)][1] }
## post-intervention dummy var
x2 <- x2Func(t, intpd)
## periods after intervention
t.post.intpd <- if(t <= intpd) {
0
} else {
ifelse(max(df$x3[which(df$firm==i)]) > 0, ## has had post-intervention-pd treatment
df$firm.t.post.intpd[which(df$firm==i & df$t==t-1)] + 1,
0)
}
##------------------------------------------------------
## Get past performance records for treat.rule == 'past'
##------------------------------------------------------
# perf.records <- if (i==1) { ## if first firm (df not updated yet)
#   if (t==1){ ystart } else { y } ## first firm must use default start value of performance or past performance in 'y' vector
# } else {
#   if (t==1) {
#     switch(benchmark.type,
#            "self"=ystart,  ## focal firm i not in data.frame yet when t==1, so just use ystart
#            "all"=df$y)
#   } else {
#     switch(benchmark.type,
#            "self" = df$y[which(df$firm == i)],
#            "all" = df$y)
#   }
# }
len.memory <- 3
.ts <- sapply(1:len.memory, function(a)max(t-a,0))
t.in.memory <- .ts[.ts > 0]
perf.records <- if (t==1) { ## if first firm record
switch(benchmark.type,
"self" = ystart, ## first time for firm i must use default start value of performance or past performance in 'y' vector
"all" = df$y)
} else {
switch(benchmark.type,
"self" = df$y[which(df$firm == i & df$t %in% t.in.memory)],
"all" = df$y[which(df$t %in% t.in.memory)])
}
# print('perf.recrods')
# print(perf.records)
## Treatment dummy (firm self-select into treatment based on treat.rule)
x3.t.minus1 <- if (t==1) { 0 } else { df$x3[which(df$firm==i & df$t==t-1)][1] }
x1 <- x1Func(x3.t.minus1,
g0, g1, y.t.minus1, v,
treat.rule = 'worst',
treat.threshold = treat.threshold, #0.5 for 'worst'; 0.1 for 'past' (?)
records=perf.records,
logit.shift, logit.scale)
# .x1.t <- x1Func(g0, g1, v[t],  y.t.minus1,
#                 logit.shift, logit.scale)
# x1[t] <- .x1.t # round(.x1.t)
# x1[t] <- sample(0:1, size = 1, prob = c(.x1.t, 1-.x1.t))
# .x1.mean <- ifelse(t==1, 0, mean(x1vec) )
# x1vec[t] <- ifelse(.x1.t > .x1.mean, 1, 0)
b3 <- b3Func(t.post.intpd, x2, type=effect.type,
w0=ifelse(effect.type=='geometric', 7, 1.3))
y <- yFunc(b0, b1, b2, b3, b4, b5, x1, x2, y.t.minus1, t, u)
df.t <- data.frame(firm=as.numeric(i), t=t, firm.t.post.intpd=t.post.intpd,
effect.type=effect.type,
y=y, x1=x1, x2=x2, x3=x1 * x2,
b1=b1, b2=b2, b3=b3,
u=u, v=v,
group=NA, group.color=NA,
stringsAsFactors = F)
df <- rbind(df, df.t)
## Update Progress Bar
## starting at 0 --> add 1 after completing first item / before progress bar update
counter <- counter + 1
setTxtProgressBar(pb, counter)
}
}
## Assign cohort group label (treatment, control)
## based on rule: treatment=treated by end; control=not treated by end
for (f in 1:n) {
idx <- which(df$firm==f & df$effect.type==effect.type)
df$group[idx] <- ifelse(any(df$x3[idx] == 1 | df$firm.t.post.intpd[idx] > 1), 'treatment', 'control')
}
ggcolors <- hue_pal()(2)
df$group.color <- ggcolors[1]
df$group.color[which(df$group=='treatment')] <- ggcolors[1]
}
close(pb)
df <- unique(df)
df$firm <- as.numeric(as.character(df$firm))
## STAGGERED DID ARRANEMENT:
## Reset each series period as t=0 when intervention selected
df.t0 <- df
df.t0$t0 <- NA
for (f in 1:n) {
x3.idx <- which(df.t0$firm==f & df.t0$x3 > 0)
f.x3.t <- ifelse(length(x3.idx)>0, min(df.t0$t[x3.idx]), NA)
df.t0$t0[which(df.t0$firm==f)] <- if (length(f.x3.t)==0 | is.na(f.x3.t)) {
(1:npds) - intpd + 1
} else {
(1:npds) - f.x3.t + 1 ## t0 = f.x3.t period
}
}
##=============================================
## PLOTS
##---------------------------------------------
if (plot.show | plot.save)
{
cat('\n rendering plots...')
cnt <- plyr::count(df$group)
prop.treat.obs <- cnt$freq[which(cnt$x == 'treatment')] / sum(cnt$freq)
prop.treat.firms <- length(unique(df$firm[which(df$group == 'treatment')])) / n
plot.main <- sprintf('past perf. = %.2f; growth = %.2f,  treat.threshold = %.2f;  prop.treat.obs = %.2f;  prop.treat.firms = %.2f',
b4, b5, treat.threshold, prop.treat.obs, prop.treat.firms)
## default ggplot2 colors
# ggcolors <- c("#F8766D", "#00BA38")
ggcolors <- hue_pal()(2)
## ----- 1. ALL INDIVIDUAL TIME SERIES ------------------
# color <- rgb(.3,.3,.8,.7)
df$firm <- as.factor(df$firm)
df.plot <- df[which(df$firm %in% 1:n),] ## filter firms
treat.map <- unique(df.plot[,c('firm','group')] ) ##***
treat.map$firm <- as.numeric(as.character(treat.map$firm))
p1 <- ggplot(data=df.plot, mapping=aes(x=t,y=y, color=firm)) +
geom_line(aes(color=firm), size=1.05, alpha=0.3) +
# geom_point(, color=rgb(0.2, 0.2, 0.8, 0.1))+
geom_hline(yintercept=0) + facet_grid( . ~ effect.type) +
theme_bw() + theme(legend.position='none') + ggtitle(plot.main) +
# guides(color=guide_legend(nrow=3,byrow=TRUE)) +
scale_color_manual(values = sapply(1:nrow(treat.map),function(a){
ifelse(treat.map$group[a]=='treatment', ggcolors[2], ggcolors[1])
}))  #rep(rgb(.2,.2,.8,.2),n)
#
# facet_wrap(.~factor(df$x1) + factor(df$x2))
if(plot.show) print(p1)
if(plot.save) {
p1.file <- sprintf('internal_intervention_all_firm_timeseries_%s.png',TIME)
ggsave(filename=file.path(dir_plot, p1.file), plot=p1,
width=plot.wide.w,heigh=plot.wide.h,dpi=plot.dpi,units='in')
}
## ---- 2. GROUP SUMMARY TIME SERIES -----------------------
df.summary <- ddply(df, .(t,effect.type,group), summarize,
min=min(y, na.rm=T),
cl=quantile(y, probs=ci.l, na.rm=T),
med=median(y, na.rm=T),
cu=quantile(y, probs=ci.u, na.rm=T),
max=max(y, na.rm=T))
# df.summary.long <- reshape2::melt(df.summary, id.vars=c('t','effect.type'),
#                                   variable.name='series', value.name = 'y')
## GROUP SUMMARY TIME SERIES
p2 <- ggplot(df.summary, aes(x=t, y=med, color=group)) +
geom_ribbon(aes(ymin=cl,ymax=cu,fill=group), alpha=.15, size=.01, lty=1) +
geom_line(size=1.2) +
geom_point(aes(x=t, y=min),pch=1,alpha=.3) + geom_point(aes(x=t,y=max),pch=1,alpha=.3) +
geom_hline(yintercept=0) + geom_vline(xintercept=intpd, lty=2) +
ylab('Y') +
facet_grid( . ~ effect.type ) +
theme_bw() + theme(legend.position='top') + ggtitle(plot.main)
if(plot.show) print(p2)
if(plot.save) {
p2.file <- sprintf('internal_intervention_group_summary_series_%s.png',TIME)
ggsave(filename=file.path(dir_plot, p2.file), plot=p2,
width=plot.wide.w,heigh=plot.wide.h,dpi=plot.dpi,units='in')
}
## ---- 3. STAGGERED DID DESIGN BY GROUPS---------------------
df.t0.summary <- ddply(df.t0, .(t0,effect.type,group), summarize,
min=min(y, na.rm=T),
cl=quantile(y, probs=ci.l, na.rm=T),
med=median(y, na.rm=T),
cu=quantile(y, probs=ci.u, na.rm=T),
max=max(y, na.rm=T))
# df.summary.long <- reshape2::melt(df.summary, id.vars=c('t','effect.type'),
#                                   variable.name='series', value.name = 'y')
p3 <- ggplot(df.t0.summary, aes(x=t0, y=med, color=group)) +
geom_ribbon(aes(ymin=cl,ymax=cu,fill=group), alpha=.15, size=.01, lty=1) +
geom_line(size=1.2) +
geom_point(aes(x=t, y=min),pch=1,alpha=.3) + geom_point(aes(x=t,y=max),pch=1,alpha=.3) +
geom_hline(yintercept=0) + geom_vline(xintercept=0, lty=2) +
ylab('Y') +
xlim(c(-intpd + 1, round(npds*0.7))) +
facet_grid( . ~ effect.type ) +
theme_bw() + theme(legend.position='top') + ggtitle(plot.main)
if(plot.show) print(p3)
if(plot.save) {
p3.file <- sprintf('internal_intervention_staggered_DiD_%s.png',TIME)
ggsave(filename=file.path(dir_plot, p3.file), plot=p3,
width=plot.wide.w,heigh=plot.wide.h,dpi=plot.dpi,units='in')
}
cat('done.\n\n')
}
##============================
## OUTPUT LIST
##----------------------------
return(list(
df=df,
df.t0=df.t0,
df.summary=df.summary,
df.t0.summary=df.t0.summary,
df.plot=df.plot,
df.plot.treat.map=treat.map,
plot.allseries=p1,
plot.group=p2,
plot.group.staggered=p3
))
}
## SIMULATION SETTINGS
n <- 40
npds <- 50
## b4 = past performance spillover
## b5 = growth
effect.types <- c('constant','quadratic','geometric')
simlist <- list(
no.perf.no.gro=list(b4=0,b5=0,effect.types=effect.types, sims=NA),
lo.perf.lo.gro=list(b4=.1,b5=.01,effect.types=effect.types, sims=NA),
md.perf.lo.gro=list(b4=.4,b5=.01,effect.types=effect.types, sims=NA),
hi.perf.lo.gro=list(b4= .7,b5=.01,effect.types=effect.types, sims=NA)
)
key <- names(simlist)[i]
sim <- simlist[[key]]
cat(sprintf('\nScenario label: %s\n\n', key))
cat(str(simlist[[key]]))
simlist[[key]]$sims <- runInternalInterventionSim(
n = n, ## NUMBER OF FIRMS
npds = npds, ## NUMBER OF PERIODS
intpd = round( npds / 5 ), ## intervention after first section
ystart = 0,
effect.types = effect.types,
benchmark.type = 'self', ## 'all', 'self'
treat.threshold = 0.03,
##
b4 = sim$b4, ## past performance
b5 = sim$b5, ## growth (linear function of time t)
##
w0 = 1.3,  ## constant
w1 = 0.3,  ## linear
w2 = 0.12 ## quadratic
)
