---
title: "Tutorial: Bayesian Counterfactual Approach"
output: pdf_document
---

This is a tutorial and illustration for (1) building a Bayesian structural time series 
(BSTS) model [Section 1] and (2) using the BSTS model as a counterfactual for causal inference [Section 2]. 

[Section 1] includes complexity of the Bayesian approach. The basic structure of a BSTS model is local trend (state space) + seasonality (state space) + regression. Each component has several ways to define, and prior settings are slightly different. Thus, we aim to show step-by-step process of adding different components in Section 1 accompanied by checking resulting BSTS models, setting up Bayesian priors,and adding regression component (Spike and Slab priors included). This part requires bsts package in R.

[Section 2] shows how to assess causal effects using the BSTS model from [Section 1] as a counterfactual, and is a straightforward process using CausalImpact packgage in R. 

```{r initExclude, setup, message=FALSE, include=FALSE}
rm(list=ls())
library(plyr)
library(dplyr)
library(tidyr)
library(tibble)
library(CausalImpact)
library(bsts)
library(did)
library(ggpubr)
library(cowplot)
library(coda)
library(Boom)
library(BoomSpikeSlab)
library(e1071)
library(forecast)  ## # library(sarima); library(qualV)
## reproducibility
rand.seed <- 9598677

set.seed(rand.seed)  

## Directories
dir_proj <- 'C:\\Users\\sdr8y\\OneDrive - University of Missouri\\Research\\BSTS'
dir_ext <- 'D:\\BSTS_external'
dir_rep <- file.path(dir_ext, 'bsts_did_replication_sensitivity')
dir_plot <- file.path(dir_proj, 'plots')
dir_r <- file.path(dir_proj,'R')
##  file prefix for saving images, writing outputs, etc.
prefix <- 'bsts-illus_vignette_'

## Load simulation functions - Actor index vectorized simulation
source(file.path(dir_r,'single_intervention_sim_vec.R')) 
## Setting up and adding state space components to state.space list
source(file.path(dir_r,'bsts_helper_functions.R')) 
## BSTS vs. DiD comparison and sensitivity analysis
source(file.path(dir_r,'bsts_did_comparison_functions.R')) 

## Knitr root dir - PDF rendering of notebook
knitr::opts_knit$set(root.dir = dir_proj)

## MAIN SIM SETTINGS
n <- 100  ## number of actors (i.e., number of time series)
npds <- 520
intpd <- round( npds * .6 )
effect.type <- c('constant') ##  c('constant','geometric','quadratic') ## c('quadratic')  
bsts.niters <- list(sm.start = 50, sm.max = 100, lg.start = 500, lg.max = 1000)  ## lg=10k for full run
bsts.ctrl.cats <- NA

##
sim.config <- list(
  ##--------Simulation settings--------------
  n = n,    ## Number of firms
  npds = npds,  ## Number of periods
  intpd = intpd, ## #intervention period = (5/6)'ths of the total periods 
  noise.level = 1.0, ## stdev of simulated noise terms
  prior.sd.scenario = 'sd.low', ## BSTS Prior SD scenario (high vs. low uncertainty in priors
  treat.rule = 'random', 
  treat.prob =  0.5,  ## ifelse(treat.rule=='random', 0.5, 1), 
  treat.threshold = 1, ## ifelse(treat.rule=='random', 1, 0.5),
  seasonality = TRUE,
  dgp.nseasons= 52,  ## ifelse(seasonality, dgp.nseasons, NA), 
  dgp.freq=  1, ##ifelse(seasonality, dgp.freq, NA),
  rand.seed = rand.seed,
  ## Dynamic treatment effect  (quadratic polynomial)
  w0 = 1.0,  ## constant
  w1 = 0.03, ## linear
  w2 = -0.00333 /sqrt(npds), ## quadratic
  w2.shift = -round( sqrt(npds)*.7 ), ## quadratic shift rightward (make all of U-shape after intervention)
  ##
  expect.mod.size = 3,  # number of covariates included in BSTS model of counterfactual
  covariates.type = 'control'
)

## SIMULATION LIST HOLDER
simlist <- list()

## state space configuration used as label
key <- 'base'
## SImulations list (for comparisons, gridsearches; use list length==1 for single model run)
simlist[[ key ]] <- sim.config
## Simulation ID
sim.id <- round(10*as.numeric(Sys.time()))


###
## Function to simulate time series data or load saved simulation data
###
processSimData <- function(simlist, key, effect.type, 
                           dgp.prior.sd.weight, sim.id=NA)
{
  
      ##-------------------------------------------------------
    ### CREATING ILLUSTRATION SIMULATION IF NONE EXISTS
    data.filepath <- file.path(dir_proj, sprintf('__bsts_vignette_1_sim-priorSd%s_%s_df.csv',
                                                 dgp.prior.sd.weight, effect.type))
    if ( ! file.exists(data.filepath) ) {
      cat(sprintf('\nIllustration data file 1 not found in project dir:\n %s.\n Simulating new illustration data set.\n',dir_proj))
      ## RUN SIMULATION -  GENERATE TIME SERIES
      simlist <- runSimUpdateSimlist(simlist, effect.types = effect.type,
                                     sim.id = sim.id, plot.show = F, plot.save = F,     
                                     dgp.prior.sd.weight=dgp.prior.sd.weight)
      # ## Save simulation for reuse with multiple BSTS models
      # simcopy <- simlist[[key]]
      ## SAVE SIMULATED DATAFRAME TO FILE
      simdf <- simlist[[key]]$sim$df
      cols.to.front <- c('t','actor','y','x1','x2','x3','c1','c2','c3','b1','b2','b3','u','v','season.val')
      cols.to.back <- c('effect.type','t.post.intpd','group','group.color','match_id','match_pd')
      simdf <- simdf[, c(cols.to.front, cols.to.back)]
      write.csv(simdf, file=data.filepath, row.names=F, na='')
      cat(sprintf('Saved simulated data to file:\n %s',data.filepath))
    } else {
      cat(sprintf('Loading data file:\n %s',data.filepath))
      simdf <- read.csv(data.filepath, stringsAsFactors = F)
    }
    
    ##--------------------------- INITS ----------------------
    bsts.df <- NULL
    bsts.df1 <- NULL
    bsts.df2 <- NULL
    cov.df.wide1 <- NULL
    cov.df.wide2 <- NULL
    ##--------------------------------------------------------
    ### SUMMARIZE BSTS (single-observation) SERIES - WITH DIFFERENT COVARIATE PREDICTORS
    bsts.df1.filepath <- file.path(dir_proj,
                                   sprintf('__bsts_vignette_1_sim-priorSd%s_%s_agg_bsts_df1-NOctrl.csv',
                                   dgp.prior.sd.weight, effect.type))
    bsts.df2.filepath <- file.path(dir_proj,
                                   sprintf('__bsts_vignette_1_sim-priorSd%s_%s_agg_bsts_df2-ONEctrl.csv',
                                   dgp.prior.sd.weight, effect.type))
    # bsts.df3.filepath <- file.path(dir_proj, 'bsts_vignette_illustration_bsts-3-SYNTHctrl_df.csv')
    f1exists <- file.exists(bsts.df1.filepath) 
    f2exists <- file.exists(bsts.df2.filepath) 
    # f3exists <- file.exists(bsts.df3.filepath) 
    if ( file.exists(data.filepath) & any(!f1exists, !f2exists)) {  # !f3exists
      
      simdf <- read.csv(data.filepath, stringsAsFactors = F) ## don't auto convert chars to factor type
      simdf <- as_tibble(simdf)
      
      ## TREATMENT
      bsts.df <- simdf %>%
        dplyr::filter( 
          ! is.na(match_id), 
          group=='treatment'
        ) %>%
        group_by(t) %>%
        summarize(
          y_treatment = mean(y, na.rm=T)
        ) 
      
      ## NO UNTREATED CONTROL GROUP - ONLY COVARIATES
      if (!f1exists) {
          cat(sprintf('\nIllustration data file 2 not found in project dir:\n %s.\n Aggregating new illustration data set.\n',dir_proj))
        cov.df.wide1 <- simdf %>%
          dplyr::filter( 
            ! is.na(match_id), 
            group=='control'
          ) %>%
          group_by(t) %>%
          dplyr::summarize(
            c1_mean = mean(c1, na.rm=T),
            c2_mean = mean(c2, na.rm=T),
            c3_mean = mean(c3, na.rm=T),
            c1_sd = sd(c1, na.rm=T),
            c2_sd = sd(c2, na.rm=T),
            c3_sd = sd(c3, na.rm=T),
            c1_skew = ifelse(length(c1)<=1, NA, skewness(c1, na.rm = T, type = 2)),
            c2_skew = ifelse(length(c2)<=1, NA, skewness(c2, na.rm = T, type = 2)),
            c3_skew = ifelse(length(c3)<=1, NA, skewness(c3, na.rm = T, type = 2))#,
          ) #%>% pivot_wider(names_from, values_from)
        bsts.df1 <- bsts.df %>% full_join(cov.df.wide1, by='t')
        bsts.df1$t <- NULL
        write.csv(bsts.df1, file=bsts.df1.filepath, row.names = F, na = '')
        cat(sprintf('Saved aggregated simulation data to file:\n %s',bsts.df1.filepath))
      } else {
          cat(sprintf('Loading data file:\n %s',bsts.df1.filepath))
          cov.df.wide1 <- read.csv(bsts.df1.filepath, stringsAsFactors = F)
      }
      
      ## 1 UNTREATED CONTROL GROUP  +  COVARIATES
      if (!f2exists) {
          cat(sprintf('\nIllustration data file 3 not found in project dir:\n %s.\n Aggregating new illustration data set.\n',dir_proj))
        cov.df.wide2 <- simdf %>%
          dplyr::filter( 
            ! is.na(match_id), 
            group=='control'
          ) %>%
          group_by(t) %>%
          dplyr::summarize(
            y_control = mean(y, na.rm=T),
            c1_mean = mean(c1, na.rm=T),
            c2_mean = mean(c2, na.rm=T),
            c3_mean = mean(c3, na.rm=T),
            c1_sd = sd(c1, na.rm=T),
            c2_sd = sd(c2, na.rm=T),
            c3_sd = sd(c3, na.rm=T),
            c1_skew = ifelse(length(c1)<=1, NA, skewness(c1, na.rm = T, type = 2)),
            c2_skew = ifelse(length(c2)<=1, NA, skewness(c2, na.rm = T, type = 2)),
            c3_skew = ifelse(length(c3)<=1, NA, skewness(c3, na.rm = T, type = 2))#,
          ) #%>% pivot_wider(names_from, values_from)
          bsts.df2 <- bsts.df %>% full_join(cov.df.wide2, by='t')
          bsts.df2$t <- NULL
          write.csv(bsts.df2, file=bsts.df2.filepath, row.names = F, na = '')
          cat(sprintf('Saved aggregated simulation data to file:\n %s\n',bsts.df2.filepath))
      } else {
          cat(sprintf('Loading data file:\n %s\n',bsts.df2.filepath))
          cov.df.wide2 <- read.csv(bsts.df2.filepath, stringsAsFactors = F)
      }
       
      
    }
    
    return(list(
      bsts.df1.filepath=bsts.df1.filepath,
      bsts.df2.filepath=bsts.df2.filepath,
      bsts.df1=bsts.df1,
      bsts.df2=bsts.df2
    ))
      
}


##=====================================================================
## ---------SCENARIOS---------------
## LOW DGP SD WEIGHT
dgp.prior.sd.weight.low <- .01
# ## HIGH DGP SD WEIGHT
# dgp.prior.sd.weight.high <- .1
##-----------------------------------
## First we simulate the data for the simulation scenario 1, in which 
## the prior SD is 0.01. 
##
## SIMULATE DATA AND RETURN DATA LIST OBJECT - LOW PRIOR SD
dat1 <- processSimData(simlist, key, effect.type, 
                       dgp.prior.sd.weight.low, 
                       sim.id)
# ## SIMULATE DATA AND RETURN DATA LIST OBJECT - HIGH PRIOR SD
# dat2 <- processSimData(simlist, key, effect.type, 
#                        dgp.prior.sd.weight.high, 
#                        sim.id)
```

# 0. Data
First load the time series data simulated from a data generating process with 
a low prior standard deviation weight (`dgp.prior.sd.weight.low=0.01`) for the purpose of this tutorial.

This data set includes the outcome series `y_treatment`, and nine 
covariate series used for regression, from which the BSTS model will select proper predictors using Spike and Slab priors later in [Section 1.4]. 

```{r, message=FALSE}
## load required library
library(bsts)              ## bsts package
library(CausalImpact)      ## causal inference estimation package
library(tibble)            #### ?

## load data
df1 <- read.csv(dat1$bsts.df1.filepath, stringsAsFactors = F) ## don't auto convert chars to factor type   #### what does this mean

df1 <- as_tibble(df1) ## wrap in a class with extra capabilities  ##### What does this mean?
print(df1)
```
We can plot this to visualize the post-intervention change in the 
outcome series `y_treatment`.
```{r outcome_plot, fig.dim = c(6,4), out.width="100%"}
## define time period
npds <- nrow(df1)       ## total number of period
intpd <- round(npds * 0.6)  ## define a pre-intervention period

## PLOT
plot(df1$y_treatment, main='Simulated Outcome Time Series (Y)',ylab='Y',xlab='Time')
abline(v=intpd, lty=2)
legend('topleft',legend=c('observed','intervention'), pch=c(1,NA),lty=c(NA,2))
```

The question of interest for reserach and practice is whether there
is a significant effect caused by the intervention at time point
`t=312`. 

For this purpose, we first build a BSTS model based on observed data before the intervention, 
and the prediction of the BSTS model after the intervention will serve as a counterfactual to assess the causal effects of the intervention. 

Thus, we create the pre-intervention outcome series `y.pre` to pass into the `bsts()` 
function. Here we replace the post-intervention periods with `NA`'s that 
represent missing values within the `R` language. This is because the 
BSTS model is trained on the pre-intervention outcome (y) data. 
We also define covariates as predictors to add regression later (section 1.4)
```{r}
## Indices of pre- and post-intervention periods
pre.idx <- 1:intpd                  ## pre-intervention period
post.idx <- (intpd+1):npds          ## post-intervention period

## Outcome (response) series
y <- df1$y_treatment

## Train on y pre-treatment but NA's post-treatment
y.pre.treat.NAs.post <- c( y[pre.idx], rep(NA,length(post.idx)) )

## Then use the post-treatment response for causal impact estimation
post.period.response <- y[post.idx]

## Covariates (predictors) - data for the "formula = y ~ predictors" argument in Regression [Section 1.4]
predictors <- df1[ , ! names(df1) %in% 'y_treatment']

```

# 1. Build a BSTS Model

## 1.1. State Space Specification: Local Trend Only

The simplest BSTS model is with only the local level in the state space. 
There are several state spaces in the bsts package for defining local trend including local level, 
local linear trend, student loca linear trend, and generalized local linear trend.

In this section, we start with the simplest local trend, local level (see section 1.6. for other types of local trend).

First, configure the model's state space by adding state components to the 
state space list `st.sp`. Here `y.pre` is passed into the state space
functions (after the state space list `st.sp`) as the outcome series. 
```{r}
## Initiate empty state space configuration list
st.sp <- list()

## Add local level to trend component of state space
st.sp <- AddLocalLevel(st.sp, y.pre.treat.NAs.post)

## Set BSTS MCMC iterations
bsts.niter <- 3000               ## Usually at least 1,000 or more recommended
```

Then, fit the BSTS model by calling the `bsts()` function to run MCMC estimation 
for `bsts.niter` draws from the stationary distribution of the Markov chain that 
specifies the posterior distribution (assuming convergence was reached,
which will be addressed below [Section 1.6])
```{r}
## Fit BSTS model
bsts.fit <- bsts(y.pre.treat.NAs.post,
                 state.specification = st.sp,
                 niter = bsts.niter,
                 seed = rand.seed)
```
Visualizing the model's behavior can help build intuition about 
what the model is doing and, ideally, about how to improve its fit to the 
characteristics of your data set. To inspect the contributions of the model 
components, we write a function that will report the model's summary, 
plot the state space components, and if there is a regression in the model, 
it will plot the coefficients and distribution of model sizes.
```{r, out.width="100%", fig.align="center", fig.dim=c(6, 4)}
###
## Define a function to summarize and visualize the BSTS model components 
###
getBstsSummaryPlots <- function(bsts.fit) {
  par(mfrow=c(1,1)) ## set plotting params to one image in plot window
  print(summary(bsts.fit))
  plot(bsts.fit, 'components')
  if (bsts.fit$has.regression) {
    plot(bsts.fit, 'coefficients')
    plot(bsts.fit, 'size')
    plot(bsts.fit, 'predictors')
    plot(bsts.fit, 'state')
  }
}
## Call our newly defined function
getBstsSummaryPlots(bsts.fit)

```
There appears to be a seasonal component to the time series, which is currently
being captured by the local trend. However, this would be a poor model to use as a 
counterfactual because it does not capture how seasonality continues
after the training window. This is visible in the lack of seasonal pattern and
quickly widening forecast intervals in the plot of the trend component 
of the state space after the intervention period, t=312. 

Then we can plot the contributions to the model's state space against
the observed outcome (black dots) to help with visual understanding of 
this model's prediction (blue line), and later for comparison with 
other models below.
```{r, out.width="100%", fig.align="center", fig.dim=c(6, 4)}
# source(file.path(dir_r,'bsts_helper_functions.R'))
plotBstsStateComps(bsts.fit, intpd=intpd, filename=NA) ##NA file does not save
```
This model appears to match the data with the trend only. However, this is only 
accurate for short (e.g., one-step ahead) predictions within the training
window. In terms of capturing the structure of the time series, this model
is underspecified and, essentially, overfitted to the training data.
While the predicted values (blue line) are one-step ahead, in-sample
predictions, the model would lose the seasonal information outside the
training window (post intervention), leaving the counterfactual series
devoid of seasonality when used for causal inference computations (see below).

Therefore, it is crucial to capture seasonality in the outcome time series 
and incorporate it into the BSTS model that will be used as the 
counterfactual for causal inference with the `CasualImpact()` function in
[Section 2](# 2. Causal Inference: BSTS as Counterfactual). 

## 1.2. State-Space Specification: Local Trend + Seasonality

To account for seasonality in the time series data generating process, 
we add a seasonal component to the state space defined by the number of seasons and the duration of each season. 
For instance, we use 52 periods with duration =1 to produce the state contribution of seasonal cycles (e.g., weekly periods each year). The augmented state space then improves 
model performance in terms of the mean absolute error (MAE) of 
one-step ahead predictions during the pre-intervention window. 
(cf. For daily data, it is recommended to use 7 for a day-of-week component with the duration of each season of 1.  )

```{r, out.width="100%", fig.align="center", fig.dim=c(6, 4)}
## Initiate empty state space configuration list
st.sp2 <- list()

## Add local level to trend component of state space
st.sp2 <- AddLocalLevel(st.sp2, y.pre.treat.NAs.post)

## Add seasonality to state space (52 weekly periods = 1 yearly cycle) 
st.sp2 <- AddSeasonal(st.sp2, y.pre.treat.NAs.post,nseasons = 52,season.duration = 1)

## Fit BSTS model: 
bsts.fit2 <- bsts(y.pre.treat.NAs.post ,
                 state.specification = st.sp2, 
                 niter = bsts.niter,
                 seed = rand.seed, ping=0)

## CALL OUR CUSTOM BSTS DIAGNOSTICS SUMMARY
getBstsSummaryPlots(bsts.fit2)
```
Here we have a seasonal component, but it is making a negligible contribution to 
the state space. Meanwhile the trend component still captures the seasonality
pre-intervention and makes only a naive local level forecast post-intervention.
That is, the expectation at `t` is the trend at `t-1` plus Gaussian noise.
Since this does not allow us to incorporate the seasonal structure into the 
state space, it would therefore would make a subpar counterfactual for 
causal inference as this data set exhibits seasonality. To address this, 
we adjust the Bayesian prior settings for the state space components (which is
a step in machine learning analyses that is commonly referred to as 
hyperparameter tuning). 

## 1.3. Bayesian Priors: Parameter Tuning

Setting up Bayesian priors is notorious for its complication. 
The conventional wisdom is to exploit information of the observed outcome. 
There are two main types of priors to set up for local level and seasonality,  priors for the variance of the state innovation errors and the initial value of the state at time 0, provided by Boom package.  
The former is defined by the option of 'sigma.prior' created by 'SdPrior' which describes the prior distribution for the standard deviation of the randomwalk increment (e.g., inverse Gamma priors). 
The latter one is 'initial.state.prior' defined by 'NormalPrior' to describe the prior distribution of the initial state vector (e.g., Gaussian distribution). If not defined, the default setting will be applied.

Examples are as below:
sigma.prior =SdPrior(sigma.guess= , 
                     sample.size = , 
                     initial.value = ,
                     fixed = , 
                     upper.limit = ),
                       
initial.state.prior =NormalPrior(mu= ,
                                 sigma= ,
                                 initial.value= ,
                                 fixed= ,
                                 upper.limit= ))

We bound outside the scope of this tutorial vignette most of the particulars of
prior elicitation. Beginning at the assumption that the researcher
has theoretical and/or contextual knowledge that can inform  
prior distributions, we focus on illustrating how to adjust the prior 
distribution settings for the `bsts()` function.

```{r, out.width="100%", fig.align="center", fig.dim=c(8, 5)}
## Get outcome (Y) standard deviation to use for adjusting priors below
y.sd <- sd(y.pre.treat.NAs.post, na.rm = T)

## Initiate empty state space configuration list
st.sp3 <- list()

## Add local level to trend component of state space
st.sp3 <- AddLocalLevel(st.sp3, y.pre.treat.NAs.post, 
  initial.state.prior = NormalPrior(mu=1, sigma = 0.25 * y.sd, fixed = FALSE),
  initial.y = y.pre.treat.NAs.post[1]
)

## Add seasonality to state space (52 weekly periods = 1 yearly cycle) 
y.sd <- sd(y.pre.treat.NAs.post, na.rm = T)
st.sp3 <- AddSeasonal(st.sp3, y.pre.treat.NAs.post, 
  nseasons = 52, 
  season.duration = 1, 
  sigma.prior = SdPrior(
    sigma.guess = 0.01 * y.sd,      ##try a low weight of outcome (Y) standard deviation
    sample.size = round(0.1 * (intpd-1)), ##prop empirical sample size (pre-int.)
    upper.limit= 1.5 * y.sd  ##try a factor of outcome (Y) standard deviation to set upper limit
  ),
  initial.state.prior = NormalPrior(
    mu = 0,   ## increase initial state prior mu
    sigma = 1.0 * y.sd  ## increase initial state prior sigma
  )
)

## Fit BSTS model:
bsts.fit3 <- bsts(y.pre.treat.NAs.post,
                 state.specification = st.sp3,
                 niter = bsts.niter,
                 seed = rand.seed, ping=0)

## CALL OUR CUSTOM BSTS DIAGNOSTICS SUMMARY
getBstsSummaryPlots(bsts.fit3)
plotBstsStateComps(bsts.fit3, intpd=intpd, filename=NA) ## NA file does not save
```

## 1.4 Regression: Local Trend + Seasonality + Regression

### 1.4.1.  Add regression `formula` to bsts() function

To add regression component to the BSTS model, we use covariate series in the `predictors` dataframe for the `data` input.
```{r, out.width="100%", fig.align="center", fig.dim=c(6, 4)}
## Initiate empty state space configuration list
st.sp4 <- list()

## Add local level to trend component of state space
st.sp4 <- AddLocalLevel(st.sp4, y.pre.treat.NAs.post,
  initial.state.prior = NormalPrior(mu=1, sigma = .25 * y.sd, fixed = FALSE),
  initial.y = y.pre.treat.NAs.post[1]
)

## Add seasonality to state space (52 weekly periods = 1 yearly cycle) 
st.sp4 <- AddSeasonal(st.sp4, y.pre.treat.NAs.post, 
  nseasons = 52, 
  season.duration = 1, 
  sigma.prior = SdPrior(
    sigma.guess = 0.01 * y.sd,      ## use outcome (Y) standard deviation
    sample.size = round(0.1 * (intpd-1)),  ## use half of pre-intervention window
    upper.limit= 1.5 * y.sd ## use outcome (Y) standard deviation to set upper limit
  ),
  initial.state.prior = NormalPrior(
    mu= 0,  
    sigma= 1.0 * y.sd  
  )
)

## Fit BSTS model: formula “y.pre ~ .” indicates inclusion of regression  
bsts.fit4 <- bsts(y.pre.treat.NAs.post ~ . ,
                 state.specification = st.sp4,
                 data = predictors,  ## covariates, default setting of one covariate is selected
                 niter = bsts.niter, 
                 seed = rand.seed, ping=0)

## Call our custom BSTS diagnostics summary
getBstsSummaryPlots(bsts.fit4)
plotBstsStateComps(bsts.fit4)
```

### 1.4.2.  Variable selection: Spike-and-Slab priors

Having proper variables in regression is a crucial step in building a counterfactual time series
that sufficiently approximates (i.e., correlates to a sufficient degree with) 
the outcomes series in the pre-intervention window. 

One of advantages in BSTS model is that variable selection among covariates is incorporated into the model within a Bayesian framework via spike-and-slab priors. 

There are two main ways to decide the number of covariate series included
in the BSTS model, which is also referred to as the "model size," or 
size of the regression covariates of the model. 

1. Pass `expected.model.size` argument into `bsts()` directly
2. Create a `SpikeSlabPrior` object to pass into `bsts()` by:
 2a. Using `expected.model.size` argument of `SpikeSlabPrior()`
 2b. Specifying inclusion probability for each covariate in `SpikeSlabPrior()`

First, the simplest method is to set the `expected.model.size` attribute 
(of the `SpikeSlabPrior()`) by passing the `expected.model.size` argument 
into the `bsts()` function directly.
```{r, out.width="100%", fig.align="center", fig.dim=c(6, 10)}
##TODO
st.sp5 <- st.sp4
#=================
# Option 1. Specify expected model size (internally creates SpikeSlabPrior)
#----------------
#   This uniformly sets prior (spike) probabilities = (1 / expected.model.size)
bsts.fit5 <- bsts(y.pre.treat.NAs.post ~ .,
                 state.specification = st.sp5,
                 data = predictors,
                 expected.model.size = 5,  ## argument passed to SpikeSlabPrior
                 niter = bsts.niter,
                 seed = rand.seed, ping=0)

bsts.fit51 <- bsts(y.pre.treat.NAs.post ~ .,
                 state.specification = st.sp5,
                 data = predictors,
                 expected.model.size = 1,  ## argument passed to SpikeSlabPrior
                 niter = bsts.niter,
                 seed = rand.seed, ping=0)
summary(bsts.fit5)

par(mfrow=c(3,1))
plot(bsts.fit5, 'coefficients', main='Expected Size = 5')
plot(bsts.fit4, 'coefficients', main='Expected Szie = 3')
plot(bsts.fit51, 'coefficients', main='Expected Szie = 1')

```

Second, you can create a `SpikeSlabPrior` object to pass into the `bsts()`
function. 

One way to do this is by using `expected.model.size` argument 
of `SpikeSlabPrior()`. This allows you to set the expected model size in a 
simple manner when all covariates are assumed to have equal naive inclusion
probabilities. This is just like the first method above but the intermediate
step of creating a `SpikeSlabPrior` object enables the researcher to adjust 
the expected model size and all other regression prior parameter settings 
in the same step. 
```{r, out.width="100%", fig.align="center", fig.dim=c(6, 4)}
st.sp6 <- st.sp5  ## Start with previous state space configuation
#=================
# Option 2. Create SpikeSlabPrior object and pass it into BSTS function
#-----------------
##----------------
##  2A. Set expected.model.size in SpikeSlabPrior (with other options)
priorObjA <- SpikeSlabPrior(x = model.matrix(y.pre.treat.NAs.post ~ ., 
                                             data=predictors),
                            y = y.pre.treat.NAs.post,
                            expected.model.size = 3, ## size in SpikeSlabPrior
                            expected.r2 = .7,
                            prior.df = .01,## obs. count
                            prior.information.weight = .01) 

## Run the bsts model with the SpikeSlabPrior object ‘priorObjA’
bsts.fit6 <- bsts(y.pre.treat.NAs.post ~ ., 
                  state.specification = st.sp6,
                  data = predictors,
                  niter = bsts.niter,
                  prior= priorObjA,
                  seed = rand.seed, ping = 0)

## Call out custom BSTS summary
getBstsSummaryPlots(bsts.fit6)
plotBstsStateComps(bsts.fit6)
```

Finally, the other way to create a `SpikeSlabPrior` object to pass
into the `bsts()`function is by specifying prior inclusion probabilities
(and estimates) for each covariates series in `predictors`. This is useful
when the researcher has prior knowledge that certain covariates are 
more likely to be important contributors to the counterfactual series
and should therefore be included in the model in more iterations 
(i.e., more MCMC draws from the posterior predictive distribution). 

```{r, out.width="100%", fig.align="center", fig.dim=c(6, 4)}
st.sp7 <- st.sp6  ## Start with the previous state-space configuation
##----------------
## 2B. Specify prior.inclusion.probabilities for each covariate
#   where length of prior spikes and means vectors should equal the number of
#    covariates
#   (i.e., this example with vector lengths = 11 implies
#      ‘data’ has 11 columns) <-- this includes intercept in example below

prior.spikes <- c(.7,.8,.9,.1,.1,.1,.1,.1,.1,.1) ## inclusion probability 
prior.means <- c(.1,.2,.3,0,0,0,0,0,0,0)   ## covariates means

## Directly set prior spike probabilities for each covariate in the prior object
priorObjB <- SpikeSlabPrior(x = model.matrix(y.pre.treat.NAs.post ~ ., 
                                             data=predictors),
                            y = y.pre.treat.NAs.post,
                            expected.r2 = .9,
                            prior.df = .1,
                            prior.information.weight = .1, ##  ~ obs. count
                            prior.inclusion.probabilities = prior.spikes,
                            optional.coefficient.estimate = prior.means)

## Run the bsts model with the SpikeSlabPrior object ‘priorObjB’
bsts.fit7 <- bsts(y.pre.treat.NAs.post ~ ., 
                  state.specification = st.sp7,
                  data = predictors,
                  niter = bsts.niter,
                  prior= priorObjB,
                  seed = rand.seed, ping = 0)

## Call out custom BSTS summary
getBstsSummaryPlots(bsts.fit7)
plotBstsStateComps(bsts.fit7)
```

## 1.5. Compare Local Trends Models 

Besides the default state space containing only a local level component, 
we can evaluate different state space configurations, such as those
including a local linear trend and semi-local linear trend.

### 1.5.0. Local Level (Trend without Slope)

This was the simple model already introduced above. As a state space without
a linear trend, this model will serve as a baseline for comparison 
with other state space configurations that contain a type of linear trend. 

### 1.5.1. Local linear trend (Trend with Level and Slope)

The local linear trend is useful for short term predictions of relatively 
well-behaved time series with clear directional movement either increasing or decreasing. 
```{r, out.width="100%", fig.align="center", fig.dim=c(6, 4)}
## Initiate empty state space configuration list
st.sp8 <- list()

## Add local level to trend component of state space
st.sp8 <- AddLocalLinearTrend(st.sp8, y.pre.treat.NAs.post, 
  level.sigma.prior=SdPrior(sigma.guess=.01 * y.sd, 
                            sample.size=round( 0.1 * (intpd-1)), 
                            upper.limit = 1.5 * y.sd,
                            fixed = F), 
  slope.sigma.prior=SdPrior(sigma.guess=.0001 * y.sd, 
                            sample.size=round( 0.1 * (intpd-1)), 
                            upper.limit = 1.5 * y.sd,
                            fixed = F), 
  initial.level.prior=NormalPrior(mu=1, sigma=.001 * y.sd, fixed = F), 
  initial.slope.prior=NormalPrior(mu=0, sigma=.001 * y.sd, fixed = F)
)

## Add seasonality to state space
st.sp8 <- AddSeasonal(st.sp8, y.pre.treat.NAs.post, 
  nseasons = 52, 
  season.duration = 1, 
  sigma.prior = SdPrior(
    sigma.guess = 0.01 * y.sd,    ## guess
    sample.size = round( 0.1 * (intpd-1)),    ## default
    upper.limit = 1.5 * y.sd
  ), 
  initial.state.prior = NormalPrior(
    mu = 0,   ##guess
    sigma = 1 * y.sd  ## guess
  )
)

## Fit BSTS model: formula “y.pre ~ .” indicates inclusion of regression  
bsts.fit8 <- bsts(y.pre.treat.NAs.post ~ . ,
                 state.specification = st.sp8,
                 data = predictors,  
                 niter = bsts.niter, 
                 prior = priorObjB,
                 seed=rand.seed, ping = 0)

## Call out custom BSTS summary
getBstsSummaryPlots(bsts.fit8)
plotBstsStateComps(bsts.fit8)
```

### 1.5.2. Semilocal linear trend (Trend with Level and slope with AR(1) drift)

The semilocal linear trend component in the BSTS model state space is 
useful for longer-term forecasts wherein the linear trend persists longer, 
so tighter prediction bounds are reasonable over longer post-intervention 
window. 
```{r, out.width="100%", fig.align="center", fig.dim=c(6, 4)}
## Initiate empty state space configuration list
st.sp9 <- list()

## Add local level to trend component of state space
st.sp9 <- AddSemilocalLinearTrend(st.sp9, y.pre.treat.NAs.post, 
  level.sigma.prior=SdPrior(
    sigma.guess=.001 * y.sd, 
    sample.size=round( 0.1 * (intpd-1)), 
    upper.limit = 1.5 * y.sd, 
    fixed = F),
  slope.mean.prior=NormalPrior(
    mu = 0, 
    sigma = .001 * y.sd), 
  slope.ar1.prior=Ar1CoefficientPrior(
    mu = 0, 
    sigma = .001 * y.sd, 
    force.stationary = FALSE, 
    force.positive = FALSE),
  slope.sigma.prior=SdPrior(
    sigma.guess=.0001 * y.sd, 
    sample.size=round( 0.1 * (intpd-1))),
  initial.level.prior=NormalPrior(
    mu = 0,
    sigma = .001 * y.sd, 
    fixed = F),
  initial.slope.prior=NormalPrior(
    mu = 0, 
    sigma = .001 * y.sd, 
    fixed = F)
)

## Add seasonality to state space
st.sp9 <- AddSeasonal(st.sp9, y.pre.treat.NAs.post, 
  nseasons = 52, 
  season.duration = 1, 
  sigma.prior = SdPrior(
    sigma.guess = .01 * y.sd,    ## guess
    sample.size = round( 0.1 * (intpd-1)),    ## default
    upper.limit= 1.5 * y.sd
  ), 
  initial.state.prior = NormalPrior(
    mu= 0,   
    sigma = 1 * y.sd,  
  )
)

## Fit BSTS model: formula “y.pre ~ .” indicates inclusion of regression  
bsts.fit9 <- bsts(y.pre.treat.NAs.post ~ . ,
                 state.specification = st.sp9,
                 data = predictors,  ## -1 excludes the outcome in 1st column 
                 niter = bsts.niter, 
                 # prior = priorObjB,
                 expected.model.size=3,
                 seed=rand.seed, ping=0)

## Call out custom BSTS summary
getBstsSummaryPlots(bsts.fit9)
plotBstsStateComps(bsts.fit9)
```

## 1.6. Model Diagnosticsand Covergence of Markov chain Monte Carlo (MCMC)
fig.dim = c(14, 10), out.width="100%",
To inspect the model's state space component contributions and check 
```{r, out.width="100%", fig.align="center", fig.dim=c(12, 8)}  
###
## Define a function to call all of our plotting, 
##    diagnostics and convergence checks functions
###

getBstsDiagnosticPlots <- function(bsts.fit, return.val=F) {
  par(mfrow=c(1,1))
  checks <- bstsPostPredChecks(bsts.fit, save.plot = F, return.val = T)
  cat('MCMC Convergence Diagnostics:\n')
  cat(checks$summary)
  if(return.val)
    return(checks)
}

## Call the new diagnostics function on the latest model
getBstsDiagnosticPlots(bsts.fit9)
```
Draws from the posterior distribution of the stationary Markov chain(s)
are used to estimate the model prediction at each time period though 
Markov chain Monte Carlo (MCMC) estimation. However, when the Markov chains
have not yet converged (usually due to insufficient MCMC burn-in period
or sampled iterations), then the iterations cannot be treated as draws from
the stationary distribution for the posterior predicted distribution. Thus, the 
estimates may be unstable and/or biased, so users must assess convergence of 
the MCMC chains. 

There are several ways to check the convergence of the MCMC including the trace plots, Heidelberger-Welch tests, and Geweke diagnostic tests. We may evalue autocorrelation using ACF/PACF autocorrelation plots and Durbin-Watson tests. 
Precision was estimated from mean absolute 1-step prediction errors and range. 

Similarly, there is need to assess how the model fits the 
observed data. 

For this purpose we plot MCMC convergence and model fit checks for the outcome 
(Y, top row panels) and the standardized residuals (bottom row panels). 

We Begin with the simple model containing only a local level `bsts.fit`.
```{r mcmc_diag_fit,  out.width="100%", fig.align="center", fig.dim=c(12, 8)}
getBstsSummaryPlots(bsts.fit)
checks <- getBstsDiagnosticPlots(bsts.fit, return.val = T)
print(checks$converged.all)
```
In the first column, the trace of the Markov chain (mean of draws per period) 
is shown for the posterior predictive distribution of the outcome (Y). 
For model fit, the observed and predicted values of Y are compared (top-center), 
where tighter alignment indicates better fit. Additionally, using the maximum 
value of Y as an auxiliary statistic, the Bayesian p-val presents the proportion of
maximum Y values (from MCMC) that are larger than the observed largest 
value of Y. Smaller values of Bayesian p-val indicate worse fit, which offers a 
similar in interpretation to the frequentist null hypothesis statistical test 
(NHST) under a null assumption of a well fitting model. 
Values of Bayesian p-val >= alpha (conventionally 0.05) would therefore not reject the 
null of good fit, whereas Bayesian p-val < alpha indicates problem(s) of fit to 
be addressed (e.g., by increasing MCMC iterations, or respecifying the state space).

With all checks now we have a BSTS model to serve as the counterfactual
for causal inference.


# 2. Causal Inference: BSTS as Counterfactual

The preferred fitted bsts model `bsts.fit4` (i.e., the model with the least 
pre-intervention, one-step-ahead cumulative absolute prediction error) 
can now be passed into the `CausalImpact()`function. 
This will use `bsts.fit4`, which was fitted on the pre-intervention 
data, in order to forecast (i.e., predict outside of the pre-intervention
sample time window) the counterfactual series (i.e., the hypothetical 
outcome series if there had been no exposure to treatment).  
The pointwise causal impact of the intervention is then computed as the 
difference between the predicted (counterfactual untreated outcome) and 
observed (actual treated outcome). The cumulative impact estimate is the 
cumulative sum of the pointwise impact estimates. 

```{r}
# ## Post period response
# y.post <- df1$y_treatment
# y.post[1:(intpd-1)] <- NA  ## SETTING values before intervention to missing
## Causal impact estimation: fitted BSTS model forecasts the counterfactual
impact.amount <- CausalImpact(bsts.model = bsts.fit9,
                              post.period.response = post.period.response,
                              alpha=0.05, model.args=list(niter = bsts.niter))
summary(impact.amount)
```
Echo the summary of causal inference results based on the model `bsts.fit`
and plot the causal impact figures (original, pointwise, cumulative).
```{r, out.width="100%", fig.align="center", fig.dim=c(6, 10)}
plot(impact.amount)
```
