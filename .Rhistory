# bsts::AddStudentLocalLinearTrend
# bsts::AddTrig
# ## Make BSTS state space configurations
state.configs.list <- list(
list(
AddLocalLevel
),
list(
AddLocalLinearTrend
),
list(
AddStudentLocalLinearTrend
),
list(
AddAr
),
list(
list(name='AddTrig', bsts.nseasons=12,  freq=1)
),
list(
list(name='AddTrig', bsts.nseasons=7,  freq=1)  ## *** incorrect seasonality in BSTS ***
),
list(
AddLocalLevel,
list(name='AddTrig', bsts.nseasons=12, freq=1)
),
list(
AddLocalLevel,
AddAr
),
list(
list(name='AddTrig', bsts.nseasons=12, freq=1),
AddAr
),
list(
AddLocalLevel,
list(name='AddTrig', bsts.nseasons=12, freq=1),
AddAr
)
)
##
npds <- 100
actor.sizes <- c(100)
intpds <- round( c(npds*2/3) )   ### round(c(3*npds/4, npds/2, npds/4))
##
noise.levels <- c(0.8, 0.3)
##
treat.rules <- c('random', 'below.benchmark')
##
autocors <- c(0, .5)
##
bsts.nseasons <- c(12, 7) ## correct, incorrect [for DGP_nseasons = 12]
seasonalities <- c(FALSE, TRUE)
linear.trends <- c(0, .05)
##
treat.thresholds <- c(.5, .25)
# g = h = i = ii = j = k = l = m = n = p = 1
##==================================
## SIMULATION CONFIGURATION BUILDER LOOP
##----------------------------------
simlist <- list()
# for (l in 1:length(bsts.nseasons)) {
#   bsts.nseason <- bsts.nseasons[l]
for (j in 1:length(intpds)) {
intpd <- intpds[j]
for (g in 1:length(actor.sizes)) {
actor.size <- actor.sizes[g]
for (h in 1:length(noise.levels)) {
noise.level <- noise.levels[h]
for (k in 1:length(autocors)) {
autocor <- autocors[k]
for (i in 1:length(treat.rules)) {
treat.rule <- treat.rules[i]
for (ii in 1:length(treat.thresholds)) {
treat.threshold <- treat.thresholds[ii]
##
for (m in 1:length(seasonalities)) {
seasonality <- seasonalities[m]
for (n in 1:length(linear.trends)) {
linear.trend <- linear.trends[n]
key <- sprintf('j%s|g%s|h%s|k%s|i%s|ii%s|m%s|n%s',
j,g,h,k,i,ii,m,n)
cat(sprintf('\n%s\n',key))
## Skip if 'random' treat.rule and treat.threshold index ii > 0
##   (random treat.rule already in simlist; no need to replicate bc treat.threshold not used)
if (treat.rule=='random' & ii>1) {
cat(sprintf(' skipping redundant config for treat.rule=random, ii=%s\n',ii))
next
}
## Append simulation configuration to simlist
simlist[[key]] <- list(
n = actor.size,    ## Number of firms
npds = 100,  ## Number of periods
intpd = intpd, ## 60% pre-intervention training / 40% post-intervention
##
noise.level = noise.level, ## stdev of simulated noise terms
##
treat.rule = treat.rule,
treat.prob = ifelse(treat.rule=='random', 0.5, 1),
treat.threshold = ifelse(treat.rule=='random', 1, treat.threshold),
b4 = 1,   ## seasonal component weight
b5 = linear.trend, ##
b9 = autocor  , ## autocorrelation
dgp.nseasons= ifelse(seasonality,  12,  NA),
dgp.freq= ifelse(seasonality,  1,  NA),
bsts.state.specs=state.configs.list,
rand.seed = 54321
)
# .debug.sim <- runSimBstsDiDComparison(simlist, plot.show = T, plot.save = T)
# stop('DEBUG STOP')
}
}
}
}
}
}
}
}
# }
##########################################
# ##_-------------------------------
# ## Save Main Sim Grid Search Run -- ***SLOW***
# ##_-------------------------------
###########################################
# sim.id <- round(10*as.numeric(Sys.time()))
## Generate simulated data for each scenario in simlist
simlist <- runSimUpdateSimlist(simlist, plot.show = T, plot.save = T)
## Run BSTS model versions and compare against DiD estimates
## local.storage=True write each sim to file; returns list of output file paths
simlist.files <- runSimUpdateCompareBstsDiD(simlist, local.storage=TRUE)
## Save simulation list as serialized data file
simlist.file <- sprintf('__GRIDSEARCH_output__%s_%s.rds', sim.id, key.strip)
## Save simulation list as serialized data file
simlist.file <- sprintf('__GRIDSEARCH_output__%s_%s.rds', sim.id, key.strip)
####################################
##  MAIN COMPARISON FUNCTION
##  - 1. runSimSingleInterventionEffectComparison() on simlist
##  - 2. DiD & BSTS results
##  - 3. comparison of DiD & BSTS performance
##   returns full simlist
######################################
runSimUpdateCompareBstsDiD <- function(simlist,     ## n, npds, intpd moved into simlist elements
effect.types=c('constant','quadratic','geometric'),
sim.id=round(10*as.numeric(Sys.time())),
local.storage=FALSE ## save updated simlist items to seprate RDS files
) {
print("runSimBstsDiDComparison()::SIMLIST INPUT:")
print(simlist)
if (length(simlist) > 0 & length(names(simlist))==0) {
names(simlist) <- 1:length(simlist)
}
##===============================
##  BSTS State Specification Comparison
##------------------------------
for (i in 1:length(simlist))
{
key <- names(simlist)[i]
key.strip <- gsub('[|]','',key,ignore.case = F, perl = T)
cat(sprintf('\n%s, %s\n',i, key))
simlist[[key]]$cordf <- data.frame()
simlist[[key]]$compare <- list(did=list(), bsts=list(), res.tbl=list())
## simulation output from simulation scenario = simlist[[key]]
sim <- simlist[[key]]$sim
# sim.id <- simlist[[key]]$sim$id
## list of BSTS State component lists
bsts.state.specs <- simlist[[key]]$bsts.state.specs
if (length(names(bsts.state.specs))==0) {
names(bsts.state.specs) <- 1:length(bsts.state.specs)
}
## Dynamic Treatment Effect Type shapes
for (k in 1:length(effect.types))
{
effect.type <- effect.types[k]
simdf <- sim$df[sim$df$effect.type == effect.type, ]
simlist[[key]]$compare$bsts[[effect.type]] <- list()
##------------------------------
## DiD
##------------------------------
# simdf <- simdf[simdf$effect.type==effect.type, ]
## Set group name 'gname' field, where 0 = control, # = period of treatment
simdf$gname <- 0
simdf$gname[simdf$group=='treatment'] <- simdf$match_pd[simdf$group=='treatment']
## Compute Multiperiod DiD for Avg Treatment Effect on Treated
ccattgt <- att_gt(yname = "y", ## "Y",
tname = "t",
idname = "actor",
gname = "gname",
xformla = ~c1 + c2 + c3,
data = simdf #,
# panel = F
)
# ccattgt
## Get first treatment group actor
tr.actor.1 <- simdf$actor[which(simdf$group=='treatment')[1]]
## SIMPLE AGGREGATION (OVERALL EFFECT) ATT
agg.simple <- aggte(ccattgt, type='simple')
# summary(agg.simple)
## DYNAMIC EFFECTS AND EVENT STUDIES
agg.es <- aggte(ccattgt, type = "dynamic")
# summary(agg.es)
# tidy(agg.es)
ggdid(agg.es)
ggsave(filename = sprintf('%s_did_dynamic_effect_ss%s_%s_%s_%s.png',
prefix,h,key.strip,effect.type,sim.id))
##-----------------------------
## Correlation of simulated to inferred
cormat <- cor(cbind(simdf$b3[simdf$actor==tr.actor.1][-1], agg.es$att.egt))
# ## MATPLOT of
# png(filename = sprintf('single_intervention_DiD_BSTS_DGP_comparison_%s.png',sim.id),
#     width = 6,height = 6,units = 'in',res=300)
# matplot(cbind(simdf$b3[simdf$actor==tr.actor.1][-1], agg.es$att.egt), type='o',pch=1:2)
# dev.off()
##
sigmamat <- cor(cbind(simdf$x1[simdf$t==intpd], ## treatment dummy at intervention period
simdf$y[simdf$t==(intpd-1)] ## performance variable at period before intervention
))
self.select.cor <- sigmamat[2,1]  ## either off-diagonal element
tmp.cordf <- data.frame(cor.type=c('dgp.did','x1t.ytm1'),
effect.type=rep(effect.type,2),
cor=c(cormat[2,1],sigmamat[2,1]))
## SAVE TO OUTPUT LIST
simlist[[key]]$cordf <- rbind(simlist[[key]]$cordf, tmp.cordf)  ## off-diagonal element of symmetric correlation matrix
# endog <- data.frame(threshold=c(1/2, 1/3,1/4,1/5,1/6),
#                     cor=c(-0.2523,-.2030,-.2086,-.2107,-.2214))
# ## Density plot
# ggplot(simdf,aes(x=y, colour=effect.type)) + geom_density(alpha=0.1, size=1.4)
##====================
## BSTS Timseries Setup
##--------------------
## Aggregate into timeseries dataframe
tsdf <- simdf %>%
dplyr::filter( ! is.na(match_id)) %>%
group_by(t, t.post.intpd, effect.type, match_pd, gname, group, group.color) %>%
dplyr::summarize(
n_in_pd = n(),
actors = paste(unique(actor), collapse = '|'),
y_mean = mean(y, na.rm=T),
y_sum = sum(y, na.rm=T),
y_sd = sd(y, na.rm=T),
y_min = min(y, na.rm=T),
y_max = max(y, na.rm=T),
x1_mean = mean(x1, na.rm=T),
x2_mean = mean(x2, na.rm=T),
x3_mean = mean(x3, na.rm=T),
##
c1_mean = mean(c1, na.rm=T),
c2_mean = mean(c2, na.rm=T),
c3_mean = mean(c3, na.rm=T),
#
b1_mean = mean(b1, na.rm=T),
b2_mean = mean(b2, na.rm=T),
b3_mean = mean(b3, na.rm=T),
#
u_mean = mean(u, na.rm=T),
v_mean = mean(v, na.rm=T)
)
tsdf$.id <- 1:nrow(tsdf)
## MAKE WIDE TIMESERIES FOR treatment,control groups in n periods
val.cols <- c('y_mean','y_sum','y_min','y_max','y_sd',
'x1_mean','x2_mean','x3_mean',
'c1_mean','c2_mean','c3_mean',
'b1_mean','b2_mean','b3_mean',
'u_mean','v_mean')
ts <- unique(tsdf$t)
groups <- unique(tsdf$group)
## init timeseries dataframe - wide
tsdfw <- data.frame(t=ts,  stringsAsFactors = F)
for (jj in 1:length(groups)) {
id.j <- which( tsdf$group == groups[ jj ] )
for (kk in 1:length(val.cols)) {
df.col <- data.frame( tsdf[ id.j , val.cols[ kk ] ] )
names(df.col) <- sprintf('%s_%s',groups[ jj ],val.cols[ kk ])
tsdfw <- cbind(tsdfw,  df.col)
}
}
# Set up pre- and post-treatment period
# pre.period <- as.Date(c("2013-01-01","2016-01-25"))
pre.period <- c(1, intpd-1)
# post.period <- as.Date(c("2016-01-26","2018-01-01"))
post.period <- c(intpd, npds)
# # BSTS causal effect analysis using CausalImpact package
# # CausalImpact option:
# # niter: Number of MCMC samples to draw. More samples lead to more accurate inferences. Defaults to 1000.
# # standardize.data: Whether to standardize all columns of the data before fitting the model (i.e., setting Bayes priors), Defaults to TRUE.
# # prior.level.sd: Prior standard deviation of the Gaussian random walk of the local level. Defaults to 0.01.
# # nseasons: Period of the seasonal components. Default to 1.
# # dynamic.regression: Whether to include time-varying regression coefficients. Defaults to FALSE.
# impact_amount <- CausalImpact(amount.impact,pre.period,post.period,alpha=0.1, model.args = list(niter = 5000))
# summary(impact_amount)
# plot(impact_amount)
dat <- tsdfw[,c('treatment_y_mean','control_y_mean','control_y_sd',#'control_y_sum', 'control_y_min','control_y_max',
'control_c1_mean','control_c2_mean','control_c3_mean'#,
# 'treatment_c1_mean','treatment_c2_mean','treatment_c3_mean',
# 'control_u_mean','control_v_mean'
)]
## Train on y pre-treatment but NA's post-treatment
y.pre.treat.NAs.post.treat <- c(dat$treatment_y_mean[1:(intpd-1)], rep(NA,npds-intpd+1))
## Then use the post-treatment response for causal impact estimation
post.period.response <- dat$treatment_y_mean[intpd:npds]
## Covariates (predictors) - Matrix for "formula = y ~ predictors" argument
predictors <- dat[, ! names(dat) %in% 'treatment_y_mean'] ## remove response; convert to matrix
# ## Covariates (predictors) - Dataframe for "data" argument
# predictors <- as.matrix(predictors)
## ADD temporal trend to covariates
predictors$covar_temp_trend <- (1:npds) + rnorm(npds, 0, noise.level)   ## * simlist$`0.rand.base`$b5
## LOOP OVER BSTS STATE SPECIFICATIONS FOR THE SAME SIMULATION RUN
for (h in 1:length(bsts.state.specs))
{
simlist[[key]]$compare$bsts[[effect.type]][[ h ]] <- list()
## h'th BSTS state space configuration (state component list)
state.conf <- bsts.state.specs[[ h ]]
##----------------------------
## State Space Configuration
##----------------------------
# ## h'th BSTS state space configuration (state component list)
# state.conf <- bsts.state.specs.l[[ h ]]
# trig.comp <- getTrigComp(state.conf)
# states.have.trig <- length(trig.comp) > 0
# bsts.nseasons <- ifelse(states.have.trig, trig.comp$bsts.nseasons, NA)
# # bsts.freq <- ifelse(states.have.trig, trig.comp$freq, NA)
nss <- length(state.conf)
## State Space Config list
st.sp <- list()
if (nss > 0) {
for (jj in 1:nss) {
addStateComp <- state.conf[[ jj ]]
## check if element is a list for an AddTrig() bsts state component
isTrig <- FALSE
if (length(names(addStateComp)) > 0) {
if ('name' %in% names(addStateComp)) {
if (addStateComp$name == 'AddTrig') {
isTrig <- TRUE
}
}
}
##
# print('runSimBstsDiDComparison():: BSTS addStateComp loop')
# print(addStateComp)
if (class(addStateComp)=='function') {
## STATE COMPONENT FUNCTIONS (excluding seasonality)
st.sp <- addStateComp(st.sp, y.pre.treat.NAs.post.treat)
} else if (isTrig) {
## SEASONALITY
st.sp <- AddTrig(st.sp, y.pre.treat.NAs.post.treat,
period = addStateComp$bsts.nseasons,
frequencies = addStateComp$freq,
method = 'harmonic')
} else {
cat('\nWarning state component excluded (not a state function or seasonal effect list\n')
}
}
} else {
## Default in CausalImpact package
st.sp <- AddLocalLevel(st.sp, y.pre.treat.NAs.post.treat)
}
# print(st.sp)
## BSTS model
bsts.model <- bsts(y.pre.treat.NAs.post.treat ~ . ,
state.specification = st.sp,
data = predictors,
niter = 5000)
# ## BSTS model for Dynamic Regression
# bsts.model <- bsts(y.pre.treat.NAs.post.treat,
#                    state.specification = st.sp,
#                    niter = 5000)
## Use BSTS prediction of counterfactual to estimate CausalImpact
impact_amount <- CausalImpact(bsts.model=bsts.model,
post.period.response = post.period.response,
alpha=0.05, model.args = list(niter = 5000))
# ##
# summary(impact_amount)
# summary(impact_amount$model$bsts.model)
# plot(impact_amount)
# summary(impact_amount)
# png(filename=sprintf('single_intervention_BSTS_CausalImpact_plot_%s_%s_%s.png',
#                         key,effect.type,sim.id))
plot(impact_amount, c('original','pointwise','cumulative'))
ggsave(filename = sprintf('%s_bsts_CausalImpact_plot_ss%s_%s_%s_%s.png',
prefix,h,key.strip,effect.type,sim.id))
# dev.off()
bsts.res <- impact_amount$series
did.res <- tidy(agg.es)
# plot(did.res)
# ## AVERAGE TREATMENT EFFECT USED IN SIMULATION
# simdf
tr.actors <- unique(simdf$actor[which(simdf$group=='treatment')])
co.actors <- unique(simdf$actor[which(simdf$group=='control')])
b3diff <- data.frame(
treat=simdf %>% dplyr::filter(group=='treatment' & actor==tr.actors[1]) %>% mutate(treat=b3) %>% dplyr::select(treat),
ctrl=simdf %>% dplyr::filter(group=='control' & actor==co.actors[1]) %>% mutate(ctrl=b3) %>% dplyr::select(ctrl),
diff=NA
)
b3diff$diff <- b3diff$treat - b3diff$ctrl
# simdf %>%
#   filter(group=='control' & actor==tr.actors[1]) %>%
#   dplyr::mutate(b3.diff=b3.treat-b3.ctrl) %>%
#   dplyr::select(b3.diff)
## Results comparison table
res.tbl <- cbind(bsts.res[ ,c('point.effect','point.effect.lower','point.effect.upper')],
did.res[ ,c('term','event.time','estimate','point.conf.low','point.conf.high')],
b3.treat=b3diff$treat,
b3.ctrl=b3diff$ctrl,
b3.att=b3diff$diff
)
## ROUND RESULTS TABLE (round numeric columns)
# res.tbl <- res.tbl[ ! is.na(res.tbl$estimate), ]
num.cols <- names(res.tbl)[ ! names(res.tbl) %in% c('term','event.time') ]
res.tbl[ , num.cols] <- round( as.numeric(res.tbl[ , num.cols]), 4)
# for (i in 1:length(num.cols)) {
#   res.tbl[ , num.cols[i] ] <- round( as.numeric( res.tbl[ , num.cols[i] ] ), 4)
# }
## MOVE ID COLUMNS TO FRONT
.col.idx <- which(names(res.tbl) %in% c('term','event.time'))
res.tbl4 <- cbind(res.tbl[, .col.idx],  res.tbl[, -.col.idx] )
# View(res.tbl4)
##PLOT INCLUSION PROBABILITIES
png(filename = sprintf('%s_BSTS_inclusion_probs_ss%s_%s_%s_%s.png',
prefix,h,key.strip,effect.type,sim.id))
plot(impact_amount$model$bsts.model,'coefficients', main=sprintf('%s %s', key,effect.type))
dev.off()
## PLOT DYNAMIC EFFECTS COMPARISON - DID vs. BSTS vs. DGP
png(filename = sprintf('%s_BSTS_dynamic_treatment_effect_comparison_ss%s_%s_%s_%s.png',
prefix,h,key.strip,effect.type,sim.id))
res.tbl.filename <- sprintf('%s: DGP = %.3f; DiD = %.3f;  BSTS = %.3f',
key.strip, mean(b3diff$diff[intpd:nrow(b3diff)]), agg.es$overall.att, impact_amount$summary$AbsEffect[1])
matplot(x = res.tbl4$event.time, y=res.tbl4[,c('point.effect','estimate','b3.att')],
type='l',lty=c(1,2,4),lwd=c(1,1,2),col=c('black','red','blue'),
main=res.tbl.filename, ylab='ATT',xlab='t')
legend('topright',legend=c('BSTS','DiD','DGP'),col=c('black','red','blue'),lty=c(1,2,4),lwd=c(1,1,2))
dev.off()
##===============================================================
## 1-step ahead prediction error
bsts.pred.er <- bsts.prediction.errors(impact_amount$model$bsts.model)$in.sample[,(1:(intpd-1))]
## Append results to output list
simlist[[key]]$compare$did[[effect.type]]$attgt <- ccattgt
simlist[[key]]$compare$did[[effect.type]]$agg.simple <- agg.simple
simlist[[key]]$compare$did[[effect.type]]$agg.es <- agg.es
simlist[[key]]$compare$did[[effect.type]]$self.select.cor <- self.select.cor
##
simlist[[key]]$compare$bsts[[effect.type]][[ h ]]$CausalImpact <- impact_amount
simlist[[key]]$compare$bsts[[effect.type]][[ h ]]$cumu.pred.error <-  cumsum(colSums(abs(bsts.pred.er)))
simlist[[key]]$compare$res.tbl[[effect.type]] <- res.tbl4
} ## // end h loop over bsts.state components
} ## // end k loop over effect types
if (local.storage) {
## Save simulation list as serialized data file
simlist.file <- sprintf('__GRIDSEARCH_output__%s_%s.rds', sim.id, key.strip)
saveRDS(simlist[[key]], file = file.path(dir_proj, simlist.file))
## FREE UP MEMORY
simlist[[key]] <- list(file = file.path(dir_proj, simlist.file))
}
} ## // end simlist loop i   ##  #; dev.off()
return(simlist)
}
# ##
# ## Helper function for checking if an AddTrig bsts component is in list
# ##
# hasTrig <- function(list.of.state.comps) {
#   for (i in 1:length(list.of.state.comps)) {
#     state.comp <- list.of.state.comps[[i]]
#     # print(i)
#     # print(state.comp)
#     if (class(state.comp) == 'list') {
#       # print('class == list')
#       if ('name' %in% names(state.comp) ) {
#         # print('name in names')
#         if (state.comp$name == 'AddTrig')
#           return(TRUE)
#       }
#     }
#   }
#   return(FALSE)
# }
##
## Get list element of specs for an AddTrig() bsts state component
##  from a list of bsts state components
##
getTrigComp <- function(state.conf.list) {
if (length(state.conf.list)==0) {
return(list())
}
if(length(names(state.conf.list))==0) {
names(state.conf.list) <- 1:length(state.conf.list)
}
if (class(state.conf.list)=='list') {
hasName <- ifelse(is.null(state.conf.list$name), FALSE, TRUE)
isTrig <- ifelse(hasName, state.conf.list$name == 'AddTrig', FALSE)
if (hasName & isTrig) {
## this list is the trig component
return(state.conf.list)
} else {
## list of state components to locate trig component
for (i in 1:length(state.conf.list)) {
compi <- state.conf.list[[ i ]]
if (length(compi)>0) {
if (class(compi)=='list') {
if (length(names(compi))>0 & 'name' %in% names(compi) & compi$name=='AddTrig') {
return(compi)
}
}
}
}
}
}
return(list())
}
simlist$`j1|g1|h1|k1|i1|ii1|m1|n1`$sim$df.plot
length(simlist)
## Run BSTS model versions and compare against DiD estimates
## local.storage=True write each sim to file; returns list of output file paths
simlist.files <- runSimUpdateCompareBstsDiD(simlist, local.storage=TRUE)
dir_ext <- 'D:\\BSTS_external'
